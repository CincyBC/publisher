/* tslint:disable */
/* eslint-disable */
/**
 * Malloy Publisher - Semantic Model Serving API
 * The Malloy Publisher - Semantic Model Serving API serves Malloy packages.  A Malloy package is a directory of Malloy models (.malloy files), Malloy notebooks (.malloynb files), and embedded datbases (.parque files) with a malloy-publisher.json manifest at the package\'s root directory. For example, see the Malloy samples packages (https://github.com/malloydata/malloy-samples) repo.
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface About
 */
export interface About {
    /**
     * Readme markdown.
     * @type {string}
     * @memberof About
     */
    'readme'?: string;
}
/**
 * 
 * @export
 * @interface BigqueryConnection
 */
export interface BigqueryConnection {
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'defaultProjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'billingProjectId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'serviceAccountKeyJson'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'maximumBytesBilled'?: string;
    /**
     * 
     * @type {string}
     * @memberof BigqueryConnection
     */
    'queryTimeoutMilliseconds'?: string;
}
/**
 * Malloy model def and result data.  Malloy model def and result data is Malloy version depdendent.
 * @export
 * @interface CompiledModel
 */
export interface CompiledModel {
    /**
     * Model\'s package Name
     * @type {string}
     * @memberof CompiledModel
     */
    'packageName'?: string;
    /**
     * Model\'s relative path in its package directory.
     * @type {string}
     * @memberof CompiledModel
     */
    'path'?: string;
    /**
     * Type of malloy model file -- source file or notebook file.
     * @type {string}
     * @memberof CompiledModel
     */
    'type'?: CompiledModelTypeEnum;
    /**
     * Version of the Malloy compiler that generated the model def and results fields.
     * @type {string}
     * @memberof CompiledModel
     */
    'malloyVersion'?: string;
    /**
     * Data style for rendering query results.
     * @type {string}
     * @memberof CompiledModel
     */
    'dataStyles'?: string;
    /**
     * Malloy model def.
     * @type {string}
     * @memberof CompiledModel
     */
    'modelDef'?: string;
    /**
     * Array of model sources.
     * @type {Array<Source>}
     * @memberof CompiledModel
     */
    'sources'?: Array<Source>;
    /**
     * 
     * @type {Array<Query>}
     * @memberof CompiledModel
     */
    'queries'?: Array<Query>;
    /**
     * Array of notebook cells.
     * @type {Array<NotebookCell>}
     * @memberof CompiledModel
     */
    'notebookCells'?: Array<NotebookCell>;
}

export const CompiledModelTypeEnum = {
    Source: 'source',
    Notebook: 'notebook'
} as const;

export type CompiledModelTypeEnum = typeof CompiledModelTypeEnum[keyof typeof CompiledModelTypeEnum];

/**
 * 
 * @export
 * @interface Connection
 */
export interface Connection {
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Connection
     */
    'type'?: ConnectionTypeEnum;
    /**
     * 
     * @type {PostgresConnection}
     * @memberof Connection
     */
    'postgresConnection'?: PostgresConnection;
    /**
     * 
     * @type {BigqueryConnection}
     * @memberof Connection
     */
    'bigqueryConnection'?: BigqueryConnection;
    /**
     * 
     * @type {SnowflakeConnection}
     * @memberof Connection
     */
    'snowflakeConnection'?: SnowflakeConnection;
}

export const ConnectionTypeEnum = {
    Postgres: 'postgres',
    Bigquery: 'bigquery',
    Snowflake: 'snowflake'
} as const;

export type ConnectionTypeEnum = typeof ConnectionTypeEnum[keyof typeof ConnectionTypeEnum];

/**
 * An in-memory DuckDB database embedded in the package.
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * Database\'s relative path in its package directory.
     * @type {string}
     * @memberof Database
     */
    'path'?: string;
    /**
     * Size of the embedded database in bytes.
     * @type {number}
     * @memberof Database
     */
    'size'?: number;
}
/**
 * Malloy model def and result data.  Malloy model def and result data is Malloy version depdendent.
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * Model\'s package Name
     * @type {string}
     * @memberof Model
     */
    'packageName'?: string;
    /**
     * Model\'s relative path in its package directory.
     * @type {string}
     * @memberof Model
     */
    'path'?: string;
    /**
     * Type of malloy model file -- source file or notebook file.
     * @type {string}
     * @memberof Model
     */
    'type'?: ModelTypeEnum;
}

export const ModelTypeEnum = {
    Source: 'source',
    Notebook: 'notebook'
} as const;

export type ModelTypeEnum = typeof ModelTypeEnum[keyof typeof ModelTypeEnum];

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * Notebook cell.
 * @export
 * @interface NotebookCell
 */
export interface NotebookCell {
    /**
     * Type of notebook cell.
     * @type {string}
     * @memberof NotebookCell
     */
    'type'?: NotebookCellTypeEnum;
    /**
     * Text contents of the notebook cell.
     * @type {string}
     * @memberof NotebookCell
     */
    'text'?: string;
    /**
     * Name of query, if this is a named query.  Otherwise, empty.
     * @type {string}
     * @memberof NotebookCell
     */
    'queryName'?: string;
    /**
     * Malloy query results. Populated only if a code cell.
     * @type {string}
     * @memberof NotebookCell
     */
    'queryResult'?: string;
}

export const NotebookCellTypeEnum = {
    Markdown: 'markdown',
    Code: 'code'
} as const;

export type NotebookCellTypeEnum = typeof NotebookCellTypeEnum[keyof typeof NotebookCellTypeEnum];

/**
 * 
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * Package name.
     * @type {string}
     * @memberof Package
     */
    'name'?: string;
    /**
     * Package description.
     * @type {string}
     * @memberof Package
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PostgresConnection
 */
export interface PostgresConnection {
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'host'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostgresConnection
     */
    'port'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'databaseName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresConnection
     */
    'connectionString'?: string;
}
/**
 * Named model query.
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * Query\'s name.
     * @type {string}
     * @memberof Query
     */
    'name'?: string;
    /**
     * Annotations attached to query.
     * @type {Array<string>}
     * @memberof Query
     */
    'annotations'?: Array<string>;
}
/**
 * A Malloy query\'s results, its model def, and its data styles.
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * Data style for rendering query results.
     * @type {string}
     * @memberof QueryResult
     */
    'dataStyles'?: string;
    /**
     * Malloy model def.
     * @type {string}
     * @memberof QueryResult
     */
    'modelDef'?: string;
    /**
     * Malloy query results. Populated only if a code cell.
     * @type {string}
     * @memberof QueryResult
     */
    'queryResult'?: string;
}
/**
 * A scheduled task.
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * Resource in the package that the schedule is attached to.
     * @type {string}
     * @memberof Schedule
     */
    'resource'?: string;
    /**
     * Schedule (cron format) for executing task.
     * @type {string}
     * @memberof Schedule
     */
    'schedule'?: string;
    /**
     * Action to execute.
     * @type {string}
     * @memberof Schedule
     */
    'action'?: string;
    /**
     * Connection to perform action on.
     * @type {string}
     * @memberof Schedule
     */
    'connection'?: string;
    /**
     * Timestamp in milliseconds of the last run.
     * @type {number}
     * @memberof Schedule
     */
    'lastRunTime'?: number;
    /**
     * Status of the last run.
     * @type {string}
     * @memberof Schedule
     */
    'lastRunStatus'?: string;
}
/**
 * 
 * @export
 * @interface SnowflakeConnection
 */
export interface SnowflakeConnection {
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'warehouse'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'database'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnowflakeConnection
     */
    'schema'?: string;
    /**
     * 
     * @type {number}
     * @memberof SnowflakeConnection
     */
    'responseTimeoutMilliseconds'?: number;
}
/**
 * Model source.
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * Source\'s name.
     * @type {string}
     * @memberof Source
     */
    'name'?: string;
    /**
     * Annotations attached to source.
     * @type {Array<string>}
     * @memberof Source
     */
    'annotations'?: Array<string>;
    /**
     * List of views in the source.\\
     * @type {Array<View>}
     * @memberof Source
     */
    'views'?: Array<View>;
}
/**
 * Named model view.
 * @export
 * @interface View
 */
export interface View {
    /**
     * View\'s name.
     * @type {string}
     * @memberof View
     */
    'name'?: string;
    /**
     * Annotations attached to view.
     * @type {Array<string>}
     * @memberof View
     */
    'annotations'?: Array<string>;
}

/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of relative paths to the databases embedded in the package.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases: async (name: string, xVersionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listDatabases', 'name', name)
            const localVarPath = `/packages/{name}/databases`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xVersionId != null) {
                localVarHeaderParameter['X-Version-Id'] = String(xVersionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of relative paths to the databases embedded in the package.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatabases(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Database>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatabases(name, xVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatabasesApi.listDatabases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of relative paths to the databases embedded in the package.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatabases(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Database>> {
            return localVarFp.listDatabases(name, xVersionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of relative paths to the databases embedded in the package.
     * @param {string} name Name of package
     * @param {string} [xVersionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public listDatabases(name: string, xVersionId?: string, options?: RawAxiosRequestConfig) {
        return DatabasesApiFp(this.configuration).listDatabases(name, xVersionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns metadata about the publisher service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns metadata about the publisher service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async about(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<About>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.about(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.about']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns metadata about the publisher service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about(options?: RawAxiosRequestConfig): AxiosPromise<About> {
            return localVarFp.about(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Returns metadata about the publisher service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public about(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).about(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModelsApi - axios parameter creator
 * @export
 */
export const ModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Malloy model.
         * @param {string} name Name of package.
         * @param {string} path Path to model wihin the package.
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel: async (name: string, path: string, xVersionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getModel', 'name', name)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('getModel', 'path', path)
            const localVarPath = `/packages/{name}/models/{path}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xVersionId != null) {
                localVarHeaderParameter['X-Version-Id'] = String(xVersionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of relative paths to the models in the package.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (name: string, xVersionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listModels', 'name', name)
            const localVarPath = `/packages/{name}/models`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xVersionId != null) {
                localVarHeaderParameter['X-Version-Id'] = String(xVersionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelsApi - functional programming interface
 * @export
 */
export const ModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a Malloy model.
         * @param {string} name Name of package.
         * @param {string} path Path to model wihin the package.
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModel(name: string, path: string, xVersionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompiledModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModel(name, path, xVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.getModel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of relative paths to the models in the package.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Model>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(name, xVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModelsApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModelsApi - factory interface
 * @export
 */
export const ModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a Malloy model.
         * @param {string} name Name of package.
         * @param {string} path Path to model wihin the package.
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModel(name: string, path: string, xVersionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CompiledModel> {
            return localVarFp.getModel(name, path, xVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of relative paths to the models in the package.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Model>> {
            return localVarFp.listModels(name, xVersionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelsApi - object-oriented interface
 * @export
 * @class ModelsApi
 * @extends {BaseAPI}
 */
export class ModelsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Malloy model.
     * @param {string} name Name of package.
     * @param {string} path Path to model wihin the package.
     * @param {string} [xVersionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public getModel(name: string, path: string, xVersionId?: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).getModel(name, path, xVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of relative paths to the models in the package.
     * @param {string} name Name of package
     * @param {string} [xVersionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelsApi
     */
    public listModels(name: string, xVersionId?: string, options?: RawAxiosRequestConfig) {
        return ModelsApiFp(this.configuration).listModels(name, xVersionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PackagesApi - axios parameter creator
 * @export
 */
export const PackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the package metadata.
         * @param {string} name Package name
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage: async (name: string, xVersionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getPackage', 'name', name)
            const localVarPath = `/packages/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xVersionId != null) {
                localVarHeaderParameter['X-Version-Id'] = String(xVersionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of the Packages hosted on this server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackagesApi - functional programming interface
 * @export
 */
export const PackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the package metadata.
         * @param {string} name Package name
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackage(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPackage(name, xVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.getPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of the Packages hosted on this server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPackages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Package>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPackages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesApi.listPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PackagesApi - factory interface
 * @export
 */
export const PackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the package metadata.
         * @param {string} name Package name
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackage(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.getPackage(name, xVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of the Packages hosted on this server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPackages(options?: RawAxiosRequestConfig): AxiosPromise<Array<Package>> {
            return localVarFp.listPackages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackagesApi - object-oriented interface
 * @export
 * @class PackagesApi
 * @extends {BaseAPI}
 */
export class PackagesApi extends BaseAPI {
    /**
     * 
     * @summary Returns the package metadata.
     * @param {string} name Package name
     * @param {string} [xVersionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public getPackage(name: string, xVersionId?: string, options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).getPackage(name, xVersionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of the Packages hosted on this server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesApi
     */
    public listPackages(options?: RawAxiosRequestConfig) {
        return PackagesApiFp(this.configuration).listPackages(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QueryresultsApi - axios parameter creator
 * @export
 */
export const QueryresultsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} name Name of package
         * @param {string} path Path to model within the package.
         * @param {string} [xVersionId] 
         * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
         * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
         * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQuery: async (name: string, path: string, xVersionId?: string, query?: string, sourceName?: string, queryName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('executeQuery', 'name', name)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('executeQuery', 'path', path)
            const localVarPath = `/packages/{name}/queryResults/{path}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }

            if (queryName !== undefined) {
                localVarQueryParameter['queryName'] = queryName;
            }

            if (xVersionId != null) {
                localVarHeaderParameter['X-Version-Id'] = String(xVersionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryresultsApi - functional programming interface
 * @export
 */
export const QueryresultsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryresultsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} name Name of package
         * @param {string} path Path to model within the package.
         * @param {string} [xVersionId] 
         * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
         * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
         * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeQuery(name: string, path: string, xVersionId?: string, query?: string, sourceName?: string, queryName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeQuery(name, path, xVersionId, query, sourceName, queryName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryresultsApi.executeQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueryresultsApi - factory interface
 * @export
 */
export const QueryresultsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryresultsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a query and its results.
         * @param {string} name Name of package
         * @param {string} path Path to model within the package.
         * @param {string} [xVersionId] 
         * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
         * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
         * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeQuery(name: string, path: string, xVersionId?: string, query?: string, sourceName?: string, queryName?: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryResult> {
            return localVarFp.executeQuery(name, path, xVersionId, query, sourceName, queryName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryresultsApi - object-oriented interface
 * @export
 * @class QueryresultsApi
 * @extends {BaseAPI}
 */
export class QueryresultsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a query and its results.
     * @param {string} name Name of package
     * @param {string} path Path to model within the package.
     * @param {string} [xVersionId] 
     * @param {string} [query] Query string to execute on the model.  If the query is paramter is set, the queryName parameter must be empty.
     * @param {string} [sourceName] Name of the source in the model to use for queryName, search, and topValue requests.
     * @param {string} [queryName] Name of a query to execute on a source in the model.  Requires the sourceName parameter is set.  If the queryName is paramter is set, the query parameter must be empty.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryresultsApi
     */
    public executeQuery(name: string, path: string, xVersionId?: string, query?: string, sourceName?: string, queryName?: string, options?: RawAxiosRequestConfig) {
        return QueryresultsApiFp(this.configuration).executeQuery(name, path, xVersionId, query, sourceName, queryName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of running schedules.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules: async (name: string, xVersionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('listSchedules', 'name', name)
            const localVarPath = `/packages/{name}/schedules`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xVersionId != null) {
                localVarHeaderParameter['X-Version-Id'] = String(xVersionId);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of running schedules.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchedules(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchedules(name, xVersionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchedulesApi.listSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of running schedules.
         * @param {string} name Name of package
         * @param {string} [xVersionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchedules(name: string, xVersionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Schedule>> {
            return localVarFp.listSchedules(name, xVersionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of running schedules.
     * @param {string} name Name of package
     * @param {string} [xVersionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public listSchedules(name: string, xVersionId?: string, options?: RawAxiosRequestConfig) {
        return SchedulesApiFp(this.configuration).listSchedules(name, xVersionId, options).then((request) => request(this.axios, this.basePath));
    }
}



